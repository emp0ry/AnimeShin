import 'dart:collection';
import 'dart:convert';
import 'dart:io';

import 'package:flutter/services.dart';

import 'sources_module.dart';
import 'remote_modules_store.dart';

typedef AssetStringReader = Future<String> Function(String assetPath);

class SourcesLoadedModule {
  const SourcesLoadedModule({
    required this.descriptor,
    required this.metaRaw,
    required this.script,
  });

  final SourcesModuleDescriptor descriptor;
  final String metaRaw;
  final String script;
}

/// Fast module loader for `assets/sources/`.
///
/// Requires `assets/sources/index.json` (generated by `tool/generate_sources_index.dart`).
class SourcesModuleLoader {
  SourcesModuleLoader({
    AssetStringReader? readAsset,
    this.indexAssetPath = 'assets/sources/index.json',
    this.maxCacheEntries = 16,
    RemoteModulesStore? remoteStore,
  })  : _readAsset = readAsset ?? rootBundle.loadString,
        _remoteStore = remoteStore ?? RemoteModulesStore();

  final AssetStringReader _readAsset;
  final String indexAssetPath;
  final int maxCacheEntries;
  final RemoteModulesStore _remoteStore;

  SourcesIndex? _index;
  bool _autoUpdateTriggered = false;

  // LRU cache: key is module id.
  final LinkedHashMap<String, SourcesLoadedModule> _cache = LinkedHashMap();

  static String _normalizeId(String raw) {
    final t = raw.trim().toLowerCase();
    final buf = StringBuffer();
    var prevDash = false;
    for (final code in t.codeUnits) {
      final isAz = code >= 97 && code <= 122;
      final is09 = code >= 48 && code <= 57;
      if (isAz || is09) {
        buf.writeCharCode(code);
        prevDash = false;
      } else if (!prevDash) {
        buf.write('-');
        prevDash = true;
      }
    }
    var out = buf.toString();
    out = out.replaceAll(RegExp(r'-+'), '-');
    out = out.replaceAll(RegExp(r'^-+'), '');
    out = out.replaceAll(RegExp(r'-+$'), '');
    return out.isEmpty ? 'remote' : out;
  }

  Future<String> _readText(String ref) async {
    final t = ref.trim();
    if (t.isEmpty) return '';

    if (t.startsWith('assets/')) {
      return _readAsset(t);
    }

    // Disk path (remote modules).
    return File(t).readAsString();
  }

  Future<SourcesIndex> loadIndex() async {
    final existing = _index;
    if (existing != null) return existing;

    // One-shot auto-update: refresh all enabled remote modules on first index
    // load so cached copies stay current when connectivity is available.
    if (!_autoUpdateTriggered) {
      _autoUpdateTriggered = true;
      try {
        await _remoteStore.downloadAllEnabledRemote();
      } catch (_) {
        // Best-effort; continue with whatever is cached locally.
      }
    }

    // Prefer remote modules (Sora-style), but fall back to bundled asset modules
    // when remote storage is unavailable/empty (e.g., first run or unit tests).
    try {
      final remote = await _remoteStore.buildDescriptors(includeDisabled: true);
      final modules = remote.toList()
        ..sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
      if (modules.isNotEmpty) {
        final out = SourcesIndex(
          generatedAt: 'remote',
          count: modules.length,
          modules: modules,
        );
        _index = out;
        return out;
      }
    } catch (_) {
      // Ignore and fall back to bundled modules.
    }

    final bundled = await _loadBundledIndex();
    _index = bundled;
    return bundled;
  }

  Future<SourcesIndex> _loadBundledIndex() async {
    // 1) Prefer the generated index.json.
    try {
      final raw = await _readAsset(indexAssetPath);
      final idx = SourcesIndex.fromJsonString(raw);
      if (idx.modules.isNotEmpty) return idx;
    } catch (_) {
      // Continue to manifest fallback.
    }

    // 2) Fallback: infer modules from AssetManifest.json.
    try {
      final raw = await _readAsset('AssetManifest.json');
      final decoded = jsonDecode(raw);
      if (decoded is! Map) {
        return const SourcesIndex(generatedAt: 'asset-manifest', count: 0, modules: []);
      }

      final keys = decoded.keys.map((k) => k.toString()).toList(growable: false);
      final moduleIds = <String>{};
      for (final k in keys) {
        final m = RegExp(r'^assets/sources/([^/]+)/\1\.(json|js)$').firstMatch(k);
        if (m != null) {
          moduleIds.add(m.group(1) ?? '');
        }
      }

      final modules = <SourcesModuleDescriptor>[];
      for (final id in moduleIds) {
        if (id.trim().isEmpty) continue;
        final jsonAsset = 'assets/sources/$id/$id.json';
        final jsAsset = 'assets/sources/$id/$id.js';
        if (!decoded.containsKey(jsonAsset) || !decoded.containsKey(jsAsset)) {
          continue;
        }

        String name = id;
        Object? version;
        Map<String, dynamic>? meta;
        try {
          final metaRaw = await _readAsset(jsonAsset);
          final metaDecoded = jsonDecode(metaRaw);
          if (metaDecoded is Map) {
            final m = metaDecoded.cast<String, dynamic>();
            name = (m['name'] ?? m['sourceName'] ?? m['title'] ?? id).toString();
            version = m['version'];
            meta = m;
          }
        } catch (_) {
          // Best-effort.
        }

        modules.add(
          SourcesModuleDescriptor(
            id: id,
            jsonAsset: jsonAsset,
            jsAsset: jsAsset,
            name: name,
            version: version,
            meta: meta,
          ),
        );
      }

      return SourcesIndex(
        generatedAt: 'asset-manifest',
        count: modules.length,
        modules: modules,
      );
    } catch (_) {
      return const SourcesIndex(generatedAt: 'asset-manifest', count: 0, modules: []);
    }
  }

  Future<List<SourcesModuleDescriptor>> listModules() async {
    return listModulesWithDisabled(includeDisabled: false);
  }

  Future<List<SourcesModuleDescriptor>> listModulesWithDisabled({
    required bool includeDisabled,
  }) async {
    final idx = await loadIndex();

    // Filter disabled modules at list-time (not during index build) so the
    // Settings screen can still display disabled modules.
    Set<String> disabled = const <String>{};
    try {
      disabled = await _remoteStore.disabledModuleIds();
    } catch (_) {
      disabled = const <String>{};
    }

    var modules = includeDisabled
        ? idx.modules
        : idx.modules.where((m) => !disabled.contains(m.id)).toList(growable: false);

    // Drop legacy "Old " modules to avoid duplicate listing when newer modules are present.
    modules = modules.where((m) {
      final name = m.name.toLowerCase();
      return !name.startsWith('old ');
    }).toList(growable: false);

    // Deduplicate by id, preferring non-"Old" names (already filtered) and first occurrence.
    final byId = <String, SourcesModuleDescriptor>{};
    for (final m in modules) {
      byId.putIfAbsent(m.id, () => m);
    }

    final out = byId.values.toList()
      ..sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
    return out;
  }

  Future<SourcesModuleDescriptor?> findById(String id) async {
    final idx = await loadIndex();
    final norm = _normalizeId(id);
    for (final m in idx.modules) {
      if (m.id == id || m.id == norm) return m;
    }
    return null;
  }

  Future<SourcesLoadedModule> loadModule(
    String id, {
    bool tryDownloadIfMissing = true,
  }) async {
    // LRU cache.
    final cached = _cache.remove(id);
    if (cached != null) {
      _cache[id] = cached;
      return cached;
    }

    var d = await findById(id);
    if (d == null) {
      // Index can be stale after import/update.
      invalidateIndex();
      d = await findById(id);
    }

    if (d == null && tryDownloadIfMissing) {
      // If a remote module exists in the registry but hasn't been downloaded
      // yet (common after import), download it on-demand.
      try {
        final norm = _normalizeId(id);
        final entries = await _remoteStore.list();
        RemoteModuleEntry? hit;
        for (final e in entries) {
          if (e.id == id || e.id == norm) {
            hit = e;
            break;
          }
        }
        if (hit != null) {
          await _remoteStore.addOrUpdateFromUrl(hit.jsonUrl, enabled: hit.enabled);
          invalidateIndex();
          clearCache();
          return loadModule(id, tryDownloadIfMissing: false);
        }
      } catch (_) {
        // best-effort
      }
    }

    if (d == null) {
      throw StateError('Module not found: $id');
    }

    final metaRaw = await _readText(d.jsonAsset);
    final script = await _readText(d.jsAsset);

    final loaded = SourcesLoadedModule(
      descriptor: d,
      metaRaw: metaRaw,
      script: script,
    );
    _cache[id] = loaded;
    _evictIfNeeded();
    return loaded;
  }

  void _evictIfNeeded() {
    while (_cache.length > maxCacheEntries) {
      _cache.remove(_cache.keys.first);
    }
  }

  void clearCache() => _cache.clear();

  void invalidateIndex() => _index = null;
}
