import 'dart:convert';
import 'dart:typed_data';
import 'package:xml/xml.dart';
import 'package:intl/intl.dart';

// Pull appVersion from your persistence model
import 'package:animeshin/feature/viewer/persistence_model.dart' show appVersion;

/// MAL list category.
enum MalListType { anime, manga }

/// Minimal shape exporter needs for anime.
class MalAnimeItem {
  MalAnimeItem({
    required this.malId,               // MAL animedb id (skip if null/0)
    required this.title,               // Preferred title
    required this.seriesType,          // TV | OVA | Movie | Special | ONA | Music | Unknown
    required this.episodesTotal,       // 0 if unknown
    required this.myStatus,            // Watching | Completed | On-Hold | Dropped | Plan to Watch
    required this.myWatchedEpisodes,   // progress
    required this.myScore,             // 0..10
    this.myStartDate,                  // yyyy-MM-dd or "0000-00-00"
    this.myFinishDate,                 // yyyy-MM-dd or "0000-00-00"
    this.myComments,
    this.myRewatching = 0,             // 0/1
    this.myRewatchingEp = 0,
    this.timesWatched = 0,
    this.updateOnImport = 1,           // 0/1
  });

  final int? malId;
  final String title;
  final String seriesType;
  final int episodesTotal;

  final String myStatus;
  final int myWatchedEpisodes;
  final int myScore;

  final String? myStartDate;
  final String? myFinishDate;
  final String? myComments;

  final int myRewatching;
  final int myRewatchingEp;
  final int timesWatched;
  final int updateOnImport;
}

/// Minimal shape exporter needs for manga.
class MalMangaItem {
  MalMangaItem({
    required this.malId,               // MAL mangadb id (skip if null/0)
    required this.title,               // Preferred title
    required this.seriesType,          // Manga | Novel | One-shot | Doujinshi | Manhwa | Manhua | OEL | Unknown
    required this.chaptersTotal,       // 0 if unknown
    required this.volumesTotal,        // 0 if unknown
    required this.myStatus,            // Reading | Completed | On-Hold | Dropped | Plan to Read
    required this.myReadChapters,
    required this.myReadVolumes,
    required this.myScore,             // 0..10
    this.myStartDate,                  // yyyy-MM-dd or "0000-00-00"
    this.myFinishDate,                 // yyyy-MM-dd or "0000-00-00"
    this.myComments,
    this.myRereading = 0,              // 0/1
    this.myRereadingChap = 0,
    this.timesRead = 0,
    this.updateOnImport = 1,           // 0/1
  });

  final int? malId;
  final String title;
  final String seriesType;
  final int chaptersTotal;
  final int volumesTotal;

  final String myStatus;
  final int myReadChapters;
  final int myReadVolumes;
  final int myScore;

  final String? myStartDate;
  final String? myFinishDate;
  final String? myComments;

  final int myRereading;
  final int myRereadingChap;
  final int timesRead;
  final int updateOnImport;
}

/// Result payload (ready-to-save bytes + suggested filename).
class MalXmlPayload {
  MalXmlPayload({required this.filename, required this.bytes});
  final String filename;
  final Uint8List bytes;
}

class MalXmlExporter {
  /// Build MAL-compatible XML for anime OR manga lists.
  static MalXmlPayload build({
    required MalListType listType,
    required String username,
    List<MalAnimeItem> animeItems = const [],
    List<MalMangaItem> mangaItems = const [],
    DateTime? now,
    String appName = 'AnimeShin', // version comes from appVersion getter
  }) {
    final dt = now ?? DateTime.now();
    final dateStr = DateFormat('yyyy-MM-dd').format(dt);
    final timeStr = DateFormat('HH:mm:ss').format(dt);

    final b = XmlBuilder();

    // XML header
    b.processing('xml', 'version="1.0" encoding="UTF-8"');

    // Comment like Taiga does (uses appVersion getter)
    b.comment(' Generated by $appName v$appVersion on $dateStr $timeStr ');

    b.element('myanimelist', nest: () {
      switch (listType) {
        case MalListType.anime:
          _buildMyInfoAnime(b, username, animeItems);
          _buildAnimeNodes(b, animeItems); // nodes filtered by malId inside
          break;
        case MalListType.manga:
          _buildMyInfoManga(b, username, mangaItems);
          _buildMangaNodes(b, mangaItems); // nodes filtered by malId inside
          break;
      }
    });

    final xml = b.buildDocument().toXmlString(pretty: true, indent: '\t');
    final bytes = Uint8List.fromList(utf8.encode(xml));
    final suffix = listType == MalListType.anime ? 'anime' : 'manga';
    final filename = 'myanimelist_${suffix}_${DateFormat('yyyyMMdd_HHmmss').format(dt)}.xml';
    return MalXmlPayload(filename: filename, bytes: bytes);
  }

  // ---- Anime helpers ----
  static void _buildMyInfoAnime(XmlBuilder b, String username, List<MalAnimeItem> items) {
    // Count ALL items (even those without malId), like Taiga does.
    final watching  = items.where((e) => _normAnimeStatus(e.myStatus) == 'Watching').length;
    final completed = items.where((e) => _normAnimeStatus(e.myStatus) == 'Completed').length;
    final onHold    = items.where((e) => _normAnimeStatus(e.myStatus) == 'On-Hold').length;
    final dropped   = items.where((e) => _normAnimeStatus(e.myStatus) == 'Dropped').length;
    final ptw       = items.where((e) => _normAnimeStatus(e.myStatus) == 'Plan to Watch').length;
    final total     = watching + completed + onHold + dropped + ptw;

    b.element('myinfo', nest: () {
      _writeInt(b, 'user_id', 0);
      _writeStr(b, 'user_name', username);
      _writeInt(b, 'user_export_type', 1);
      _writeInt(b, 'user_total_anime', total);
      _writeInt(b, 'user_total_watching', watching);
      _writeInt(b, 'user_total_completed', completed);
      _writeInt(b, 'user_total_onhold', onHold);
      _writeInt(b, 'user_total_dropped', dropped);
      _writeInt(b, 'user_total_plantowatch', ptw);
    });
  }

  static void _buildAnimeNodes(XmlBuilder b, List<MalAnimeItem> items) {
    for (final it in items) {
      if ((it.malId ?? 0) <= 0) continue; // Only export nodes with valid MAL id
      b.element('anime', nest: () {
        _writeInt(b, 'series_animedb_id', it.malId!);
        _writeCData(b, 'series_title', it.title);
        _writeStr(b, 'series_type', _normAnimeType(it.seriesType));
        _writeInt(b, 'series_episodes', it.episodesTotal);

        _writeInt(b, 'my_id', 0);
        _writeInt(b, 'my_watched_episodes', it.myWatchedEpisodes);
        _writeStr(b, 'my_start_date', _dateOrZeros(it.myStartDate));
        _writeStr(b, 'my_finish_date', _dateOrZeros(it.myFinishDate));
        _writeCData(b, 'my_fansub_group', '');
        _writeStr(b, 'my_rated', '');
        _writeInt(b, 'my_score', _clamp(it.myScore, 0, 10));
        _writeStr(b, 'my_dvd', '');
        _writeStr(b, 'my_storage', '');
        _writeStr(b, 'my_status', _normAnimeStatus(it.myStatus));
        _writeStr(b, 'shiki_status', _normalizeShikiStatusAnime(it));
        _writeCData(b, 'my_comments', it.myComments ?? '');
        _writeInt(b, 'my_times_watched', it.timesWatched);
        _writeStr(b, 'my_rewatch_value', '');
        _writeInt(b, 'my_downloaded_eps', 0);
        _writeStr(b, 'my_tags', '');
        _writeInt(b, 'my_rewatching', it.myRewatching);
        _writeInt(b, 'my_rewatching_ep', it.myRewatchingEp);
        _writeInt(b, 'update_on_import', it.updateOnImport);
      });
    }
  }

  // ---- Manga helpers ----
  static void _buildMyInfoManga(XmlBuilder b, String username, List<MalMangaItem> items) {
    // Count ALL items (even those without malId)
    final reading   = items.where((e) => _normMangaStatus(e.myStatus) == 'Reading').length;
    final completed = items.where((e) => _normMangaStatus(e.myStatus) == 'Completed').length;
    final onHold    = items.where((e) => _normMangaStatus(e.myStatus) == 'On-Hold').length;
    final dropped   = items.where((e) => _normMangaStatus(e.myStatus) == 'Dropped').length;
    final ptr       = items.where((e) => _normMangaStatus(e.myStatus) == 'Plan to Read').length;
    final total     = reading + completed + onHold + dropped + ptr;

    b.element('myinfo', nest: () {
      _writeInt(b, 'user_id', 0);
      _writeStr(b, 'user_name', username);
      _writeInt(b, 'user_export_type', 2);
      _writeInt(b, 'user_total_manga', total);
      _writeInt(b, 'user_total_reading', reading);
      _writeInt(b, 'user_total_completed', completed);
      _writeInt(b, 'user_total_onhold', onHold);
      _writeInt(b, 'user_total_dropped', dropped);
      _writeInt(b, 'user_total_plantoread', ptr);
    });
  }

  static void _buildMangaNodes(XmlBuilder b, List<MalMangaItem> items) {
    for (final it in items) {
      if ((it.malId ?? 0) <= 0) continue; // Only export nodes with valid MAL id
      b.element('manga', nest: () {
        _writeInt(b, 'series_mangadb_id', it.malId!);
        _writeCData(b, 'series_title', it.title);
        _writeStr(b, 'series_type', _normMangaType(it.seriesType));
        _writeInt(b, 'series_chapters', it.chaptersTotal);
        _writeInt(b, 'series_volumes', it.volumesTotal);

        _writeInt(b, 'my_id', 0);
        _writeInt(b, 'my_read_chapters', it.myReadChapters);
        _writeInt(b, 'my_read_volumes', it.myReadVolumes);
        _writeStr(b, 'my_start_date', _dateOrZeros(it.myStartDate));
        _writeStr(b, 'my_finish_date', _dateOrZeros(it.myFinishDate));
        _writeInt(b, 'my_score', _clamp(it.myScore, 0, 10));
        _writeStr(b, 'my_status', _normMangaStatus(it.myStatus));
        _writeStr(b, 'shiki_status', _normalizeShikiStatusManga(it));
        _writeCData(b, 'my_comments', it.myComments ?? '');
        _writeInt(b, 'my_times_read', it.timesRead);
        _writeInt(b, 'my_rereading', it.myRereading);
        _writeInt(b, 'my_rereading_chap', it.myRereadingChap);
        _writeStr(b, 'my_tags', '');
        _writeInt(b, 'update_on_import', it.updateOnImport);
      });
    }
  }

  // ---- Normalizers ----
  static String _normAnimeStatus(String s) {
    switch (s) {
      case 'Watching':
      case 'Completed':
      case 'On-Hold':
      case 'Dropped':
      case 'Plan to Watch':
        return s;
      // Common aliases → MAL wording
      case 'Planned':
      case 'Planning':
      case 'PlanToWatch':
      case 'Plan_to_Watch':
        return 'Plan to Watch';
      default:
        return 'Watching';
    }
  }

  static String _normAnimeType(String s) {
    switch (s.toUpperCase()) {
      case 'TV': return 'TV';
      case 'OVA': return 'OVA';
      case 'MOVIE': return 'Movie';
      case 'SPECIAL': return 'Special';
      case 'ONA': return 'ONA';
      case 'MUSIC': return 'Music';
      default: return 'Unknown';
    }
  }

  static String _normMangaStatus(String s) {
    switch (s) {
      case 'Reading':
      case 'Completed':
      case 'On-Hold':
      case 'Dropped':
      case 'Plan to Read':
        return s;
      case 'Planned':
      case 'Planning':
      case 'PlanToRead':
      case 'Plan_to_Read':
        return 'Plan to Read';
      default:
        return 'Reading';
    }
  }

  static String _normMangaType(String s) {
    final u = s.toUpperCase();
    if (u == 'MANGA') return 'Manga';
    if (u == 'NOVEL' || u == 'LIGHT_NOVEL' || u == 'LN') return 'Novel';
    if (u == 'ONE-SHOT' || u == 'ONESHOT' || u == 'ONE_SHOT') return 'One-shot';
    if (u == 'DOUJIN' || u == 'DOUJINSHI') return 'Doujinshi';
    if (u == 'MANHWA') return 'Manhwa';
    if (u == 'MANHUA') return 'Manhua';
    if (u == 'OEL') return 'OEL';
    return 'Unknown';
  }

  // ---- Small utils ----
  static String _dateOrZeros(String? s) {
    // MAL accepts "0000-00-00" for unknown dates.
    if (s == null || s.trim().isEmpty) return '0000-00-00';
    final rx = RegExp(r'^\d{4}-\d{2}-\d{2}$');
    return rx.hasMatch(s) ? s : '0000-00-00';
  }

  static void _writeInt(XmlBuilder b, String name, int value) {
    b.element(name, nest: value.toString());
  }

  static void _writeStr(XmlBuilder b, String name, String value) {
    b.element(name, nest: value);
  }

  static void _writeCData(XmlBuilder b, String name, String value) {
    b.element(name, nest: () => b.cdata(value));
  }

  static int _clamp(int v, int min, int max) {
    if (v < min) return min;
    if (v > max) return max;
    return v;
  }

  // ---- Shikimori helpers ----
  // For anime
  static String _normalizeShikiStatusAnime(MalAnimeItem it) {
    if (it.myRewatching == 1) {
      return 'Rewatching';
    }
    switch (it.myStatus) {
      case 'Watching':
        return 'Watching';
      case 'Completed':
        return 'Completed';
      case 'On-Hold':
        return 'On-Hold';
      case 'Dropped':
        return 'Dropped';
      case 'Plan to Watch':
        return 'Plan to Watch';
      default:
        return 'Watching';
    }
  }

  // For manga
  static String _normalizeShikiStatusManga(MalMangaItem it) {
    if (it.myRereading == 1) {
      return 'Rereading';
    }
    switch (it.myStatus) {
      case 'Reading':
        return 'Reading';
      case 'Completed':
        return 'Completed';
      case 'On-Hold':
        return 'On-Hold';
      case 'Dropped':
        return 'Dropped';
      case 'Plan to Read':
        return 'Plan to Read';
      default:
        return 'Reading';
    }
  }
}
